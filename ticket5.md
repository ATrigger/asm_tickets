# Билет 5
## различия x86 / x64

64-битное расширение х86. Называется по-разному (интел и амд называют одно и то же по-разному). Расширение называется amd64. Т.е. когда вышло, все его называли так. Но интелу не нравилось амд в начале, так что они придумали em64. Сейчас это называется x86-64. Ну либо просто x64. Ну а 86-битный режим называется как назывался. Таблицы страниц устроены так же. 

## Что поменялось для программ?
#### расширился размер регистров. 
Добавились (в 64-битном режиме) набор регистров, который называется rax, rbx ... При этом старые регистры - это младшие части новых. 

Число регистров в х86 мало. Обычно их где-то 32. Т.к. регистров мало, то важно, какие переменные класть в регисры, а какие - нет. 

Когда амд делали 64-битную версию, они сделали ещё больше регистров.  Точнее, они добавили ещё 8 регистров. Но не стали давать им имена, т.е. они называются l8 и т.д.

Есть проблема, что нужно расширить число регистров в кодировании комманд. Комманды с новыми регистрами занимают на 1 бит (или байт?) больше. 

У новых регистров тоже есть обозначиния, чтобы обратиться к младшим частям.

reg_prefix меняет смысл чисел, которые говорят про 8-битные регистры. Т.е. с новыми регистрами нельзя обратиться к 8-битным версиям. 

#### изменения в работе операций

Как работают операции? в 32-битном режиме, если что-то записано в eax, а потом перетираются младшие биты, то после этого в eax будет старшая часть без изменений, а младшая часть перетрётся. Но в 64 версии перетирается старшая часть, когда меняется младшая. Т.к. процессор не знает, нужна ли нам часть или нет, то выполнение арифметической операции зависит от предыдущей команды

partial register pipeline

Суть в том, что в зависимости от того, используется старшая часть или нет, конвеер ведёт себя по-разному. Так что чтобы всё было быстрее, нужно в явном виде сделать xor по переменной. 

в 64 битном режиме всегда записывается регистр целиком, т.е. нет partial write. А если регистр перетирается всегда целиком, то уже нет этой проблемы с конвеерм. 

Откуда взялся reg_prefix? Что-бы что-то вставить в код комманд, нужно что-то удалить. Где они нашли в пространстве комманд больше 1 байта?

Они пожертвовали короткими формами комманд inc, dec. В 32 они были у всех 8-битных и у всех 16-битных. Т.е. всего 32 комманды. Ну и в 64 режиме ими пожертвовали, чтобы получить reg_prefix. Но это не так уж и страшно, потому что всё-равно остались длинные версии комманд.

В чём разница между inc и add? inc не меняет carry flag. 

Чтобы избежать partial write, gcc всегда использует add. 

не reg_prefix, a rex_prefix. 

В остальном, код для 32 и для 64, который генерится, очень похож. 

#### поддержка position-independent кода. 

Есть программы, у каждой своё адресное пространство на 4 гб. 

Все программы загружалисть в какое-то одно место. (exe). Проблема в том, что есть ещё dll. И они загружаются в память тогда, когда программа уже работает. И память может быть уже занята. 

А что, если код программы просто взять и переместить куда-то в другое место? jump & call продолжат работать, потому что они - относительные. Но сломаются обращения к глобальным переменным. Кроме того, сломаются таблицы виртуальных функций. Обычно это не проблема, потому что код загружается просто по фиксированному адресу, даже в длл. Т.е. у длл есть адрес, куда загрузиться. И у каждой длл свой. Но если мы не знаем наперёд, какие будут длл, то есть 2 варианта. Первый вариант: все места с глобальными обращениями переделывать (помечать). Таблица релокаций - там, где хранятся глобальные адреса. Самое простое действие - просто сместить все адреса. Но недостаток в том, что dll не будут шарить код. Т.е. для каждого процесса код длл копируется. А это плохо, потому что тогда любой хелло ворлд будет по 50-100 мегабайт. Поэтому сделали так: у каждой длл есть какой-то base address. Т.е. адрес, куда нужно загружаться. Если память там свободна, то ничего не релацируется.  Винда использует memory mapped files, оперативка тратиться не будет. Но если память по base_address занята, то делается релокация. 

Есть код, который называется position-independent. Это такой код, который не надо релоцировать. И под линуксом все .so скомпилированны именно так. Т.е. в любом месте ищется свободное место, там мепается файл и библиотека загружается туда. 

Как это сделать? Проблема - сделать обращения к глобальным переменным относительно регистра ip. Как получить регистр ip без move? 

call label
label: pop ebx

но так не делают. 

у процессора внутри есть много механизмов для того, чтобы сделать более быстрое выполнение. Так что можно этим воспользоваться и немного переписать код. Пары call & ret почти всегда совпадают, так что на самом деле у процессора есть ещё один стек для возвращаемых значений. Так что если не сделать ret, то все последующие возвраты будут медленными. 

В x86 amd включили возможность адресоваться к памяти относительно регистра rip. Т.е. при чтении можно написпть mov ebx, [rip + 0x1234]

С точки зрения обычных программ, это все отличия. 64-битные регистры, больше регистров, при любых операциях обнуляется старшая часть и есть rex_prefix. 

Есть комманда nop. Что она делает? Меняет регистр сам с собой. 

иногда нужно сделать так, чтобы метка была выровнена по какому-то адресу. Но много нопов нельзя вставлять, т.к. он тоже как бы вычисляется и тратит время. Так что есть nop'ы разной длины. 

xor - рекомендованный способ занулять регистр. Поэтому, если xor регистра с ним же, то нет зависимости от его значения. Если бы такая зависимость была, то это называлось бы false-dependency. 

popcount - считает число битов (где считает? ) и записывает в eax.  

Эта команда похожа на всякие add, xor и т.д. И взяли и сделали popcount так же. Но арифметические операции все зависят от первого агрумента. И с popcount получилось так же. Если бы компилятор знал про false-dependency, то проблемы бы не было. 

Количество трюков, скажем, с false dependency на редких коммандах просто зашкаливает. 
