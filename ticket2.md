# Билет 2
## Сегментная адресация

особенность x86. в большинстве других архитектур ничего подобного нет. 

в 8086 были 16-битные указатели. Но можно было адресоваться к миллиону ячеек. Мил - это порядка 2^20. Откуда ещё 4 бита? На самом деле, адрес хранился в 2 числах - сегмент и смещение. 

к одной ячейке можно обратиться разными способами. Потому что реальный адрес получается по формуле 
seg * 16 + off.

###A20 Line (https://en.wikipedia.org/wiki/A20_line)
Эта штука нужна для обратной совместимости с 808х и 80186. На них была 20и-разрядная адресная шина, поэтому мы могли юзать только 1 мегабайт(2^20 бит) адресов. Но, так как мы все адреса хранили в виде сегмент : смещение, естественно, что могло возникнуть переполнение адреса. Так, адрес FFFF:0010 был эквивалентен адресу 0000:0000 из-за потери бита, который лежит свыше 20ого. Эта фича активно использовалась многими досовскими программами. Логично, что при переходе на 80286 с 24х-разрядной адресной шиной, такие программы переставали работать. Тогда был придуман А20-GATE, который позволял отключать 21ый провод шины. По-умолчанию он включен и управляется через контроллер клавиатуры(where is logic?). Позднее был придуман a20 handler, который динамически управляет адресацией и позволяет программам, работающим в реальном режиме(см. далее), использовать адреса от FFFF:0010 до FFFF:FFFF.

допустим, что регистры - 16 бит. Команда обращения к памяти имеет 1 аргумент - это 16-байтовый регистр. А где лежит второе число? (сегмент). В специальном регистре. ds (data segment). Есть несколько регистров, которые указывают на сегменты. Напремер, data segment, или stack segment, cs( maybe call).

ещё есть es, fs, gs (e - extended)

можно указать другой регистр: mov ax, es : [bx].

регистры типа sp, bp имеют дефолтный регистр sp. 

Перед коммандами, которые работают с памятью, можно указать префикс, который заставит комманду использовать другой регистр для сегмента.

Комманды, которые используют регистры разного размера, имеют разные префиксы. Есть префикс изменения разрядности. 

процессор может работать в двух режимах: в режиме совместимости и в новом режиме. Если в 16-битном коде начать работать с 32-битными коммандами, то комманды будут больше из-за префикса. Тоже самое и в 32-битном режиме при работе с 16-битными коммандами.

Есть и другие префиксы. Например, префикс lock. Он делает комманду атомарной. 

Одна комманда может иметь несколько префиксов и все они будут работать. Это позволяет делать очень длинные комманды. 

А что будет, если указать много префиксов изменения разрядности? Так никто не пишет обычно, но если написать, то поведение, видимо, зависит от процессора. Например, в amd будет использоваться последний префикс.

Для 8086 операционной системой была dos. Дос - это однозадачная система. Программы клались как бы на стек. Работала та, которая находилась на вершине стека. Сама система лежала где-то вначале памяти.

т.к. была возможность обратиться ко всей памяти, то программа должна была знать, в какой части памяти она начинается. И такая информация хранилась как раз в сегментном регистре.

(т.е. у каждой программы свой сегмент).

было соглашение, что вся доступная память после программы является свободной. 

в x86 были какие-то уникальные комманды.
movs{b,w,d} //разная буква - разный регистр с индексом
loads{b,w,d}
shos{b,w,d}

loadsb делает mov al, [si], lea si, [si + 1]

префикс rep говорит, что комманду нужно повторять cx раз

Кстати, простые реализации memcpy как раз делаются через rep и movs

Но получается так, что более короткие сложные комманды работают долго, потому что внутри все комманды разбиваются на микроинструкции и более высокоуровневая комманда разбивается на большее число инструкций. Поэтому, например, все оптимизированные версии glibc не используют сложных комманд.

s в коммандах вроде movs означает, что эта комманда для работы со строками. 

В досе нет никакой виртуальной памяти и программа может попортить память программы, которая её вызвала.

highmem - программа могла менять верхний кусок памяти своим кодом и говорить, что максимальная память немного уменьшилась.

как туда передавалось управление? при помощи прерываний.

### protected mode

всё, что было рассказано - про старые технологии. Потом появился 286 - в нём появился protected_mode. Он позволяет изолировать операционную систему от программ и программы друг от друга. Механизм, который появился тогда - segmentation. Перевод - сегментная адресация. 286 могли работать в 2 режимах - защищенный и реальный (совместимый со старыми). Там как раз была эта фишка с seg * 16 + off. А что можно было делать в защищенном? Сегменты лежат не подряд, а разбросаны по памяти. При обращении проверялось, чтобы оффсет не выводил за пределы сегмента.

Ещё можно было сделать уровни привелегий кода. Изначально их было 4. Самый привилигированный - 0. На нём операционная система. На 3 уровне программы. Промежуточные планировались там для драйверов всяких, но на самом деле они не используются в современных операционных системах. 

Как указываются эти базы и лимиты? появился новый регистр, который называется GDTR. Он имел размер шесть байт и представлял из себя 2 байта на лимит (лимит - это размер - 1) + linear address (на оставшиеся 4 байта). 

Что представляла из себя сама таблица? последовательность элементов, где каждый элемент - это некоторый сегмент. 

Один элемент таблицы - 8 байт. Что в них входит? 
limit - 0...15
base (0..15) 16 ... 31
base (16...23)

О сегменте хранится какая-то дополнительная информация. Например, можно ли исполнять данные из этого сегмента? Нет сегментов, которые нельзя писать и исполнять. Уровень привилегий тоже хранится в этой таблице. Какой нужен уровень для обращения к этому сегменту. Самый странный бит - это direction.

В x86 стек растёт вниз. Есть сегменты, у которых обращение идёт от нуля до лимита, а есть сегменты, у которых адреса - отрицательные, т.е. нужно делать проверку, не превысили ли ноль. Ну и направление как раз определяется битом direction.

### различные таблицы дескрипторов
если раньше сегменты клались со смещением в 16 байт, то в защищенном режиме можно было сделать global desctiptor table. В этой таблице хранился адрес начала сегмента, размер (лимит - это размер - 1). + права доступа к этому сегменту. 

(это всё про защищенный режим)

mov ax, 16
mov es, ax // присваивание сегментного регистра
mov es:[0x1234], bl - старый код.

в самом сегменте кроме базы и лимита хранится уровень привилегий. 

в защищенном режиме:
первые 2 бита - это RPL (доступ) 
потом идёт бит global. Затем идёт N - номер в глобальной таблице дескрипторов. 

сегментные регистры на самом деле имеют 80 бит. первые 16 - это то, к чему есть доступ. А остальные - это то, что хранится в глобальной таблице дескрипторов. 

ldt - local descriptor table

(регистры gdt & ldt)

gdt - 48 бит. лдт - 16 бит. Он хранит номер файлового дескриптора, где хранится gdt.

как это использовать? есть 2 программы, у каждой свои сегменты специально для неё. К гдт каждая программа может обращаться. Так что программа могла бы взять сегмент другой программы. Лдт - это как раз механизм защиты. 

А файл дескриптор у каждого процесса свой. (таблица файл дескрипторов) 

call gate - бит из гдт. Если стоит битик, то это сегмент, а если не стоит - то это - call gate.

Суть в том, что должно быть запрещено прыгнуть из низкопривелегированного сегмента в сегмент, где лежит ос и где высокие права доступа. Но иногда это нужно сделать, например, при системных вызовах. Для этого и используется call gate. В нём хранится, кто в него может прыгнуть.

нельзя узнать, где лежат call gate, для этого используются соглашения. В бсд просто договорились, какой селектор будут использовать для системных вызовов.

сейчас этот механизм не используется, потому что у интел он реализован неэффективно. 

Как определяется уровень привилегий кода, который сейчас исполняется? В регистре ... хранится, какой сегмент сейчас исполняется.

В защищенном режиме появилась такая штука, как набор таблиц. IDT - interrupt descriptor table. Таблица дескрипторов прерываний. 

в защищенном режиме нельзя просто так взять и разрешить программам вызывать прерывания. Потому что прерывания могут быть и для устройств. Эта таблица состоит из элементов, которые очень похожи на call gate. Каждый элемент хранит сегмент, смещение, и уровень привилегий, чтобы туда прыгнуть. 

trap gate - он не запрещает прерывания
interrupt gate - запрещает прерывания. разница очень небольшая

процессор позволяет запрещать прерывания. Есть регистр EFLAGS  if - interrupted flag. Если он в true, то прерывания разрешены. Этот флаг значит, могут ли прерывания приходить от устройств. Если прерывания не могут прийти от устройств, то они (прерывания) будут висеть, пока флажок снова не поставят

sti & cli - 

про таблицу дескрипторов прерываний программы могут вообще не знать. Только в одном случае это может понадобиться - когда програма хочет сгенерить прерывание. int 0x80.

у idt данные записаны в регистре - idtr. у таблицы тоже есть база, лимит и всё это хранится в этом регистре.

на винде драйверы могут менять эту таблицу. 

Последний вид дескрипторов, которые бывают в гдт - это TSS

tss - task state segment 

выглядит, как обычный сегмент. Разница в том, что про tss процессор знает что-то про содержимое сегмента. В этом сегменте записано значение всех регистров, сегментных регистров ...

tr - task register. при переключении на какой нибудь tss, процессор читает своё состояние из tss.

Т.е. это поддержка многозадачности на уровне процессора. 

Как это планировалось использовать? Есть глобальная система дескрипторов. + на каждую программу по tss + ещё что-то. Сейчас это не используют, потому что просто сохранить в регистры быстрее, чем использовать tss. Для защиты аля ldt используется страничная адресация.

для системных вызовов сделали (в 386) syscall. И не нужно пользоваться всеми таблицами. Т.е. int использовать не надо. Винда, начиная с висты, использует сискалл.

idt до сих пор используется, например, для старых программ.

Суть в том, что сложные комманды, которые переключают процессы, состоят из более простых. Но они должны работать в общем случае. А если их написать самому, то их можно заточить под конкретное использование.

[<<](https://github.com/Owntage/asm_tickets/blob/master/ticket1.md) [>>](https://github.com/Owntage/asm_tickets/blob/master/ticket4.md)
