если раньше сегменты клались со смещением в 16 байт, то в защищенном режиме можно было сделать global desctiptor table. В этой таблице хранился адрес начала сегмента, размер (лимит - это размер - 1). + права доступа к этому сегменту. 
---
(это всё про защищенный режим)
---
mov ax, 16
mov es, ax // присваивание сегментного регистра
mov es:[0x1234], bl - старый код.
---
в самом сегменте кроме базы и лимита хранится уровень привилегий. 
---
в защищенном режиме:
первые 2 бита - это RPL (доступ) 
потом идёт бит global. Затем идёт N - номер в глобальной таблице дескрипторов. 
---
сегментные регистры на самом деле имеют 80 бит. первые 16 - это то, к чему есть доступ. А остальные - это то, что хранится в глобальной таблице дескрипторов. 
---
ldt - local descriptor table
---
(регистры gdt & ldt)
---
gdt - 48 бит. лдт - 16 бит. Он хранит номер файлового дескриптора, где хранится gdt.
---
как это использовать? есть 2 программы, у каждой свои сегменты специально для неё. К гдт каждая программа может обращаться. Так что программа могла бы взять сегмент другой программы. Лдт - это как раз механизм защиты. 
---
А файл дескриптор у каждого процесса свой. (таблица файл дескрипторов) 
---
call gate - бит из гдт. Если стоит битик, то это сегмент, а если не стоит - то это - call gate.
---
Суть в том, что должно быть запрещено прыгнуть из низкопривелегированного сегмента в сегмент, где лежит ос и где высокие права доступа. Но иногда это нужно сделать, например, при системных вызовах. Для этого и используется call gate. В нём хранится, кто в него может прыгнуть.
---
нельзя узнать, где лежат call gate, для этого используются соглашения.
---
в бсд просто договорились, какой селектор будут использовать для системных вызовов.
---
сейчас этот механизм не используется, потому что у интел он реализован неэффективно. 
---
Как определяется уровень привилегий кода, который сейчас исполняется? В регистре ... хранится, какой сегмент сейчас исполняется.
---
---
В защищенном режиме появилась такая штука, как набор таблиц. IDT - interrupt descriptor table. Таблица дескрипторов прерываний. 
---
в защищенном режиме нельзя просто так взять и разрешить программам вызывать прерывания. Потому что прерывания могут быть и для устройств. Эта таблица состоит из элементов, которые очень похожи на call gate. Каждый элемент хранит сегмент, смещение, и уровень привилегий, чтобы туда прыгнуть. 
---
trap gate - он не запрещает прерывания
interrupt gate - запрещает прерывания. разница очень небольшая
---
процессор позволяет запрещать прерывания. Есть регистр EFLAGS  if - interrupted flag. Если он в true, то прерывания разрешены. Этот флаг значит, могут ли прерывания приходить от устройств. Если прерывания не могут прийти от устройств, то они (прерывания) будут висеть, пока флажок снова не поставят
---
sti & cli - 
---
про таблицу дескрипторов прерываний программы могут вообще не знать. Только в одном случае это может понадобиться - когда програма хочет сгенерить прерывание. int 0x80.
---
у idt данные записаны в регистре - idtr. у таблицы тоже есть база, лимит и всё это хранится в этом регистре.
---
на винде драйверы могут менять эту таблицу. 
---
Последний вид дескрипторов, которые бывают в гдт - это TSS
---
tss - task state segment 
---
выглядит, как обычный сегмент. Разница в том, что про tss процессор знает что-то про содержимое сегмента.
---
В этом сегменте записано значение всех регистров, сегментных регистров ...
---
tr - task register. при переключении на какой нибудь tss, процессор читает своё состояние из tss.
---
Т.е. это поддержка многозадачности на уровне процессора. 
---
Как это планировалось использовать? Есть глобальная система дескрипторов. + на каждую программу по tss + ещё что-то.
---
сейчас это не используют, потому что просто сохранить в регистры быстрее, чем использовать tss. 
---
для защиты аля ldt используется страничная адресация.
---
для системных вызовов сделали (в 386) syscall. И не нужно пользоваться всеми таблицами. Т.е. int использовать не надо. Винда, начиная с висты, использует сискалл.
---
idt до сих пор используется, например, для старых программ.
---
Суть в том, что сложные комманды, которые переключают процессы, состоят из более простых. Но они должны работать в общем случае. А если их написать самому, то их можно заточить под конкретное использование.