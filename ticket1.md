#  Билет 1
Список тем:
- регистры x86
- базовые команды
- флаги

## регистры
Рассказ совсем с нуля. Как работает компьютер внутри себя? есть процессор и память. У памяти есть 2 операции - чтение и запись. Чтение принимает на вход индекс и возвращает значение. Память можно считать массивом с индексами. Вторая операция - это запись. Есть какой-то диапазон ячеек. Какой диапазон значения? один байт. В базовом варианте операции - побайтовые. Как действует процессор? есть ip - инстракшн поинтер. Говорят, что это - регистр. Регистр - это память прямо на процессоре (статическая). Читается ячейка ип и, в зависимости от комманды, читаются другие ячейки. (Если комманда - многобайтовая). Далее ип сдвигается. Всё это делается миллиарды раз в секунду. Само собой, модель - упрощенная. На самом деле чтение - не побайтовое, а пачками по 64 байта (128). Да и комманды не исполняются последовательно, а параллельно (конвеер). Но снаружи поддерживается иллюзия, что операции - побайтовые, а операции - последовательные. Регистров много. Есть регистры общего назначения. Они прямо на процессоре и к ним можно обратиться непосредственно. У каждой из них есть свое название. ax, bx, cx, dx. Каждый регистр хранит по 16 бит.
## команды
### арифметические
Какие есть операции у процессора? Стоит понимать, что каждая комманда на самом деле представляется номером, а не названием. Самая базовая - присваивание. mov ax, 0x1234. Ещё мув может присваивать регистры друг к другу. Ещё эта комманда умеет читать из памяти. mox ax, [0x1234]. На самом деле, когда в двухбайтовый регистр читается память, читается 2 байта, а не 1. В зависимости от того, какой байт (старший, или младший) сдвинут, архитектура либо биг ендиан, либо литтл ендиан. Если младший байт имеет меньший индекс - это литтл ендиан. В качестве индекса можно тоже указать регистр. mov ax, [bx]. Именно так работают указатели. В икс86 нет комманды, у которой 2 аргумента - это память. Это потому, что архитектура - рег-мем. Поэтому надо сначала считать в регистр, а потом записать его в другое место.

На самом деле, в икс86 есть комманда, которая похожа на мем-мем. Но в современных арх. такого нет. А всё потому, что такие комманды усложняют конвеер.

Какие ещё бывают комманды? Арифметические. Сложение. Первый аргумент - то, куда запишется результат. Вторая - источник. Т.e. destination & source. Вообще комманды бъются на микрооперации, которые исполняются параллельно. 

Что ещё есть? sub. (-=). Ещё есть побитовые операции. 

что с умножением? она не похожа на сложение и вычитание. Это связанно с тем, что умножение было сильно дороже сложения. 
mul принимает один регистр. mul bx. Результат пишется в 2 регистра. - ах и вх. Это нужно для того, чтобы на процессоре эффективно делать длинку.

Деление работает аналогично. div bx. результаты куда-то там пишутся. Есть 2 результата - остаток и результат деления.

Что будет, если поделить на 0? Будет прерывание. Процессор остановит свою работу и передаст работу обработчику прерываний. На современных осях это какая-то системная функция. Но с точки зрения программиста результат деления на 0 зависит от оси. 

Как работал обработчик прерываний в старых 8086? обработчики хранились в начале памяти. В каждой ситуации вызывался свой обработчик. Эти указатели записывает ось (или не ось, если ось пишется самостоятельно.)

ещё можно поделить на ноль в обработчике исключений. 

про флаги нет смысла особо говорить.

бывают восьмибитные регистры, которые дают доступ к первой половине какого-нибудь большого регистра.
### не арифметические
продолжение обзора комманд. из икс 86. Сейчас хватает комманд на то, чтобы можно было посчитать какое-нибудь арифметическое выражение. Но как делать условные переходы? Есть комманда jump. После комманды пишется имя метки (лейбл). Далее где-то в коде можно написать этот лейбл и после комманды процессор будет исполнять инструкции, которые начинаются с этой метки. Как эта инструкция кодируется? Можно было бы кодировать адресс метки. Тогда такая адресация называлась бы абсолютной (но в икс 86 она не используется). Вместо этого он хранит число относительно следующей инструкции. Такое число имеет знак (т.к. можно прыгнуть назад). Если написать eb 00 00, то будет джамп на следующую комманду (т.е. бесполезная комманда). Если написать eb fd ff, то это будет бесконечный цикл. У джампа есть короткая форма, которая хранит оффсет в однобайтовом виде. Ассемблер может либо давать возможность выбирать тип джампа, либо выбирать его самостоятельно (если оффсет влезет в один байт, то берется однобайтовая комманда). Ещё есть условные переходы, их очень много. Как ими пользоваться?

cmp - сравнивает свои аргументы и результат идёт в регистр FLAGS. Каждый бит - это флаг. Один из флагов устанавливает цмп. А комманды перехода смотрят на значение флагов и делают (или не делают) переход. При этом сравнение регистров идёт как unsigned. 
#### неполный список флагов
- jg - greater
- jl - lower
- je - equals 
- zf - zero flag
- cf - carry flag
- of - overflow flag
- s - sign flag

от этих флагов зависит джамп. 

керри - перенос, который при беззнаковых. оверфлоу - при знаковых операциях.

Как комманда cmp выставляет флаги? цмп работает так: цмп работает так же, как и комманда sub. Только саб записывает результат, а цмп - нет. Так что флаги ставятся так же, как если бы написали саб.

Как саб выставляет флаги? 
- зеро - если результат 0. 
- sf - < 0
- cf - если происходит заём (как если бы числа были беззнаковыми).
- of - если было переполнение. 

#### разные интересные замечания
1. то, что саб и, скажем, mul выставляют флаг переполнения, это позволяет сделать длинную арифметику.
2. -fsanitize=undefined как раз вставляет после каждой комманды jo и если он выполняется, программа завершается (т.к. было переполнение).
3. если числа равны, то выставится и зеро флаг и флаг равно, так что комманды je & jz имеют одно и то же значение.
4. Если знаем, как делать меньше, то можно сделать и больше.
5. Кейз со знаковым сравнением: там есть диаграмма с тем, что будет в флагах при различных значениях 2 аргументов. 
6. jl = sf != of. это значит, что зеро флаг - нулевой.
7. add a b выставляет флаги так же.
8. Когда нет переноса, но есть оверфлоу? надо сложить 2^15 + 1.
9.На операцию можно смотреть как на знаковую и как на беззнаковую. Значит ли это, что есть 2 типа сложений - знаковое и беззнаковое? 
10. Так как комманды условного перехода используются, в основном,  для бранчей, то они бывают только однобайтовыми.
11. оффсет считается в байтах, потому что инструкции на икс 86 могут быть разного размера. И никак не посчитать число инструкций (суффикс инструкции может быть инструкцией)
12. shr, shl, sar - они были унарными (имеют только один аргумент, записанный в ax). это комманды битового сдвига. Они сдвигают регистр ах. Разница в том, что в одном случае это происходит как для беззнаковых, а во втором - как для знаковых (арифметический, логический сдвиги). Бит, который сдвинулся, записывается в керри флаг. Это можно использовать, если есть, например, длинка и возведение в степень. В более поздних версиях появились бинарные версии этих комманд (для переменного числа бит).
13. rol, ror - циклические сдвиги. (влево и вправо). 
14. если в плюсах сделать a >> 3 | a << 5, то компилятор это спалит и сделает циклический сдвиг.
15. можно считать флаги напрямую.
16. Есть инструкции, которые есть именно на процессоре, они работают быстро. Но некоторые инструкции работают медленно (они есть для обратной совместимости).

## команды обращения к памяти. (режимы адресации). 

В 8086 при mov ax, [**], в качестве ** можно было вписать не любой регистр. (там было несколько фиксированных комбинаций). 

Комманда loop. 

Так как каждая комманда работает с каким-то своим набором регистров, сложно писать компиляторы. intel старались убирать эти несимметричности. Например, были добавлены трёхаргументные комманды.

Всё осложняется тем, что у x86 мало регистров. Это приводит к тому, что нужно вставлять больше обращений к памяти.

В 386 добавили возможность писать 0x1234 + [ax, bx, cx, dx, si, di, sp, bp] + [1, 2, 4, 8] + [ax, bx, cx, dx, si, di, bp].

режим адресации - это то, как можно обратиться к памяти. Такой навороченный режим адресации, который добавился в 386, можно использовать не только в mov, но и в других коммандах.

Почему во второй группе регистров нет sp? Потому что были проблеммы с кодированием.

### изменения в обращениях к памяти в x86
Какие расширения сделали в икс 86? Для начала, сделали регистры 32 битными. Старые регистры расширили, теперь старые регистры являются частью соответствующего нового регистра. ax & eax

Идея составлять регистры из половинок на самом деле была плохой, но это осознали гораздо позже. Это было потому, что при суперскалярной архитектуре нужно смотреть, от каких регистров зависят коммады (чтобы запускать их на конвеер параллельно или задерживать одну, пока не выполнится другая). 

Что делать, если нужно работать со старшей частью регистра? можно просто записать в младший и сдвинуть. 

Появление сложной адресации позволило сделать комманду lea register [register]. Она вычисляет адресс, по которому хочет обратиться, а потом не обращается по нему, а выдаёт его в качестве результата. В чём польза такой комманды? Так как есть этот сложный режим адресации, то можно сделать что-то вроде lea ax, [bx + 4 + bx]. Т.е. комманда считает адресс, куда бы комманда обратилась. Это просто сокращает число комманд. Современные компиляторы очень активно используют эту комманду в коде, который они генерируют.

леа вообще не выставляет флаги. Этим можно пользоваться, если нужно, чтобы на одной итерации не использовались флаги с прошлой итерации.

Последняя вещь - икс 86 - это самый удачный процессор для реализации длинной арифметики. Например, есть комманда, которая может сделать сложение с учитыванием керри флага (addc).  Если бы не было такой комманды, то не ясно, как тогда быть с керри флагом, который нужно учесть. Нужно было бы городить джампы. Аналогично, есть subc. 

Недавно интел опубликовали ещё набор инструкций, который ещё облегчает реализацию длинки. mulx, addcx, adox. Что это такое? адц икс - работает, как addc, но не меняет флаг оверфлоу. adox - работает как addc, но использует флаг оверфлоу вместо керри флага. и не меняет керри флаг (а вообще, стоит уточнить, как это работает, Сорокин немного путается и путает других).

Новые операции сложения, которые могут учитывать оверфлоу флаг, позволяют делать длинку на трёх числах (сложение трёх числел). Просто первое сложение делается с учётом керри, а второе - с учётом оверфлоу.

