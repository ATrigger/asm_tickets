# Билет 6
### SSE

- mmx
- sse
- sse2
- sse3
- sse4
- sse4.1
- sse4.2
- avx
- avx2

### Введение

Начиная с Pentium P54C, все процессоры Intel содержат расширение mmx. Это расширение предназначено для того, чтобы можно было за 1 команду делать операцию сразу над массивом чисел. Для этого в MMX были добавлены новые команды и регистры.

#### регистры

Появилось восемь 64-битных регистра: MMO..MM7. Физически, никаких новых регистров не добавилось. Вместо этого используются регистры FPU (Floating Point Unit). fpu - отдельная часть, которая занимается операциями с плавающей точкой. У FPU есть свои команды и регистры. В частности, есть регистры RO..R7, к которым раньше не было прямого доступа. С появлением MMX эти регистры можно трогать через mm0..mm7. 

Так как у mmx нет своих регистров, то нужно помнить, что после операций с плавающей точкой значения mm0..mm7 могут измениться.

#### типы данных MMX
1. двойные слова по 32 бита, упакованные в один регистр. Первое слово занимает биты 63..32, второе - 31..0.
2. четыре 16-битных слова.
3. упакованные байты 

#### особенность операций (насыщение)
Имеет место специальный способ обработки переполнений - насыщение. Когда операция приводит к тому, что происходит выход за границы типа, подставляется максимально (минимально) допустимое значение (Например, 127 для однобайтового формата). Это очень полезно, например, при работе с цветами. Насыщение позволяет цвету стать чисто белым или чисто чёрным. 

#### команды пересылки данных MMX
1. movd(dest, source) - пересылка двойных слов. В качестве аргумента может быть либо регистр ммх, либо обычный регистр. Но один из регистров должен быть обязательно регистром ммх. Если приёмник - регистр ммх, а источник - обычный регистр, то значение будет записано в младшую половину (31..0), а старшая часть будет заполнена нулями. Если источник - ммх, а принимает обычный, то биты аналогично берутся из младшей половины. 
2. movq(dest, source) - тоже самое, но для слов по 64 бита. Аргументом может быть либо регистр ммх, либо переменная. 

#### команды преобразования типов MMX
1. packsswb(dest, source) - упаковывает и насыщает слова со знаком в байты. Команда packsswb копирует 4 слова из источника в 4 младших байта в приёмнике и в 4 старших байта. При этом, если не удаётся вместить значение в тип, то вместо значения подставляется максимально (минимально) допустимое. 
2. packssdw(dest, source) - двойные слова в слова
3. packuswb(dest, source) - упаковка 4 слов в 4 байта с беззнаковым насыщением.
4. punpckhbw(dest, source) - записывает в приёмник, начиная от старшего, байты из из источника и приёмника, чередуя их. Т.е. сначала записывается самый старший байт приёмника, потом самый старший бит источника и т.д. Такая команда может использоваться для увеличения размера типа, если старшие половинки будут содержать нули. 
5. punpckhwd(dest, source) - тоже самое, но для двух старших слов
6. punpckhdq(dest, source) - для двойных слов
7. punpcklbw(dest, source) - аналогичная команда, которая записывает байты через 1, но на этот раз байты берутся из младших половинок. Такая команда позволяет, по сути, взять младшую половину регистра и увеличить размер типа. 
8. punpcklwd(dest, source) - тоже самое для слов
9. punpckldq(dest, source) - тоже самое для двойных слов.

#### арифметические команды MMX
1. padd{b, w, d} - покоординатное сложение. Если происходит перенос, то он просто игнорируется и получается, что 255 + 1 = 0.
2. padds{b, w} - поокоординатное сложение с насыщением. 
3. paddus{b, w} - беззнаковое насыщение.
4. psub{b, w, d} - вычитание, которое работает, как самое первое сложение
5. psubs{b, w} - вычитание с насыщением -128 - 1 = -128
6. psubus{b, w} - вычитание с беззнаковым насыщением 0 - 1 = 0


### изменения после MMX

В первом sse регистры можно было рассм. 2 способами: либо как 4 флота, либо 2 дабла. Не поддерживается расширенная точность. 

Какие есть операции на регистрах? есть векторные операции. Т.е. есть 2 набора по 4 числа и можно их покомпонентно сложить. в sse такое называется addps. 



все покомпонентные операции:
addps (с флотами)
addpd (с даблами).

ещё sse заменял оригинальный сопроцессор. Сопроцессор - это что-то типо стека. У сопроцессора есть проблема, потому что каждая команда сдвигает стек поинтер и получается, что все команды выполняются только последовательно. инстракшн параллелизма нет.

addss - scalar float. addps - packed.

ещё есть покомпонентное вычитание, умножение, деление. Ну и ещё всякие операции вроде обратного корня, максимума, минимума и т.д. Ещё есть битовые операции. andps, orps, xorps. Ещё andnps - a and not b. А отрицания нет. Но его можно выразить через эти операции. Суть в том, что нот, на самом деле, не нужен. Иногда бывает так, что есть 2 набора. и одно число из первых двух выбирается в зависимости от того, какого значение 3 числа. 

sse2 получил расширенный набор команд. С 4 флотами можно теперь работать так, будто это целые числа. При этом на числа можно смотреть, как на однобайтовые, двубайтовые и т.д. Ну и, соответственно, сделали команды для работы с целыми числами. 

Команды присваиваний в sse: с командами присваивания есть такая тенденция: чем более новая архитектура, тем больше появляется всяких разных обращений в памяти. Вот, скажем, в х86 обращение к памяти - это вообще часть какой-то другой команды. А в арм код просто завален всякими разными видами чтения и записи в память. 

Т.к. sse - более новая архитектура, есть команды чтения-записи.

movapd // a - aligned
movaps // u - unaligned - т.е. если передали не выровненный адрес, то она всё-равно будет чтение, но, возможно, более медленное. 
movdqa
movupd
movups
movdqu

pd, ps - packed double precision, ps - packed single precision. dq - если работать, как с целыми числами. (???) К чему это разделение? В процессоре разные execution unit могут работать с разными типами чисел. 

в sse3 добавили горизонтальные операции. Т.е. те операции, которые были в sse2, они были вертикальными. А горизонтальные - это когда внутри одного регистра делаются какие-то операции. 

haddps - есть 2 набора по 4 числа. В качестве результата будет набор из 4 чисел, в котором первое число - это сумма первых двух чисел первого набора, 2 число - сумма вторых двух чисел первого набора и т.д.

появиласть команда FISTTP - это, на самом деле, команда сопроцессора. Как переводится флоат в инт? По дефолту стояло так, что флоат приводился к ближайшему целому. Но по сишным правилам надо к 0. И вот только в sse3 сделали команду, которая позволяет кастить флоат к инт по сишным правилам за 1 команду.

сsse3 - ещё немного горизонтальных операций. 

полезные команды: pshuf* - в регистре есть 16 байт. В качестве аргументов - регистр с данными и регистр - маска. Что получается? Получается перестановка элементов. Это позволяет как угодно скопировать элементы. Сначала можно было шафлить только флоат, потом сделали для даблов, а потом и для байт.

blendf - даётся 3 аргумента: 2 числа и маска . Если маска - отрицательна - то выбирается одно число, а если положительная - то другое. 

Если нужно делать много вычислений на одних данных, то sse позволяет делать это быстрее, чем суперскалярная архитектура.

В avx расширили регистры. Их расширили как по количеству (до 31, а было 16), так и по размеру. Регистры теперь 256 бит. Т.е. код для sse стал работать ещё в 2 раза быстрее. avx512 расширяет это ещё больше. Т.е. уже 64 байта на регистр. Получается в 64 раза быстрее. Или можно написать в 64 раза больше кода.

А может ли компилятор заюзать sse, чтобы оптимизировать какой-нибудь произвольный код? Вообще говоря, есть флажок, который позволяет указать, что порядок вычислений чисел с плавающей точкой не имеет значения.

Вообще, компилятор не может менять код на неэквивалентный.

## примеры
### матрицы

с матрицами сложнее, потому что для того, чтобы умножать строку на столбец, нужно, чтобы и строка и столбец были последовательно в памяти. А для этого нужно транспонировать вторую матрицу. Но т.к. иногда это невозможно, то она транспонируется по частям, blendf.
### формат пикселей
зачем использовать ещё sse? Для перевода формата пикселей. Скажем, было rgba, а нужно argb. Если для этого использовать скалярный код, то всё упрётся не в память, а в процессор. 
Как для такого использовать sse? Записать в регистр сколько-то пикселей и сделать blendf. 

в sse есть команды, которые читают из одного массива и пишут в другой. И получается так, что появляются лишние чтения-записи в память. Так что есть флажок, который говорит, что нужно заигнорить кеш. А значит, и все протоколы когерентности. non-temporal записи. Всё пишется в такой буфер, который никто не видит. Это ускоряет работу алгоритмов, которые пишут в память, на 2/3.

### strlen
ещё один пример - нужно сделать ф-ю вроде strlen, т.е. нужно найти первый символ в массиве, который удовл. какому-то предикату. Это можно сделать при помощи sse. Т.е. можно идти по массиву большими пачками, пока не попадётся пачка, в которой есть нулевой символ. А дальше перейти на скалярный код. Но проблема в том, что многие строчки не очень большие и получается так, что сразу переходим на скалярный код.

как узнать позицию первой единицы в числе? 

arr[((v&-v)*0x077cb531u) >> 27]
{0,1,3,8,2,29,14,24,3,30, 27,20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 14, 16, 7, 26, 12, 18, 6, 11, 3, 10, 9} //WTF

-это на теории кодирования. Там это не расскажут, но расскажут про циклические коды. Короче, при помощи этой штуки можно пробежать биты от 0 до 31.  На самом деле, это даже не в теории кодирования. Это из комбинаторики. Последовательности De Bruijn.

[<<] (https://github.com/Owntage/asm_tickets/blob/master/ticket5.md)
