# Билет 6
### SSE
начало пропущено, что-то про sse. 

В первом sse регистры можно было рассм. 2 способами: либо как 4 флота, либо 2 дабла. Не поддерживается расширенная точность. 

Какие есть операции на регистрах? есть векторные операции. Т.е. есть 2 набора по 4 числа и можно их покомпонентно сложить. в ссе такое называется addps. 

- mmx
- sse
- sse2
- sse3
- sse4
- sse4.1
- sse4.2
- avx
- avx2

все покомпонентные операции:
addps (с флотами)
addpd (с даблами).

ещё sse заменял оригинальный сопроцессор. Сопроцессор - это что-то типо стека. У сопроцессора есть проблема, потому что каждая команда сдвигает стек поинтер и получается, что все команды выполняются только последовательно. инстракшн параллелизма нет.

addss - scalar float. addps - packed.

ещё есть покомпонентное вычитание, умножение, деление. Ну и ещё всякие операции вроде обратного корня, максимума, минимума и т.д. Ещё есть битовые операции. andps, orps, xorps. Ещё andnps - a and not b. А отрицания нет. Но его можно выразить через эти операции. Суть в том, что нот, на самом деле, не нужен. Иногда бывает так, что есть 2 набора. и одно число из первых двух выбирается в зависимости от того, какого значение 3 числа. 

ссе2 получил расширенный набор команд. С 4 флотами можно теперь работать так, будто это целые числа. При этом на числа можно смотреть, как на однобайтовые, двубайтовые и т.д. Ну и, соответственно, сделали команды для работы с целыми числами. 

Команды присваиваний в ссе: с командами присваивания есть такая тенденция: чем более новая архитектура, тем больше появляется всяких разных обращений в памяти. Вот, скажем, в х86 обращение к памяти - это вообще часть какой-то другой команды. А в арм код просто завален всякими разными видами чтения и записи в память. 

Т.к. ссе - более новая архитектура, есть команды чтения-записи.

movapd // a - aligned
movaps // u - unaligned - т.е. если передали не выровненный адрес, то она всё-равно будет чтение, но, возможно, более медленное. 
movdqa
movupd
movups
movdqu

pd, ps - packed double precision, ps - packed single precision. dq - если работать, как с целыми числами. (???) К чему это разделение? В процессоре разные execution unit могут работать с разными типами чисел. 

в ссе3 добавили горизонтальные операции. Т.е. те операции, которые были в ссе2, они были вертикальными. А горизонтальные - это когда внутри одного регистра делаются какие-то операции. 

haddps - есть 2 набора по 4 числа. В качестве результата будет набор из 4 чисел, в котором первое число - это сумма первых двух чисел первого набора, 2 число - сумма вторых двух чисел первого набора и т.д.

появиласть команда FISTTP - это, на самом деле, команда сопроцессора. Как переводится флоат в инт? По дефолту стояло так, что флоат приводился к ближайшему целому. Но по сишным правилам надо к 0. И вот только в ссе3 сделали команду, которая позволяет кастить флоат к инт по сишным правилам за 1 команду.

сссе3 - ещё немного горизонтальных операций. 

полезные команды: pshuf* - в регистре есть 16 байт. В качестве аргументов - регистр с данными и регистр - маска. Что получается? Получается перестановка элементов. Это позволяет как угодно скопировать элементы. Сначала можно было шафлить только флоат, потом сделали для даблов, а потом и для байт.

blendf - даётся 3 аргумента: 2 числа и маска . Если маска - отрицательна - то выбирается одно число, а если положительная - то другое. 

Если нужно делать много вычислений на одних данных, то ссе позволяет делать это быстрее, чем суперскалярная архитектура.

В avx расширили регистры. Их расширили как по количеству (до 31, а было 16), так и по размеру. Регистры теперь 256 бит. Т.е. код для ссе стал работать ещё в 2 раза быстрее. avx512 расширяет это ещё больше. Т.е. уже 64 байта на регистр. Получается в 64 раза быстрее. Или можно написать в 64 раза больше кода.

А может ли компилятор заюзать ссе, чтобы оптимизировать какой-нибудь произвольный код? Вообще говоря, есть флажок, который позволяет указать, что порядок вычислений чисел с плавающей точкой не имеет значения.

Вообще, компилятор не может менять код на неэквивалентный.

## примеры
### матрицы

с матрицами сложнее, потому что для того, чтобы умножать строку на столбец, нужно, чтобы и строка и столбец были последовательно в памяти. А для этого нужно транспонировать вторую матрицу. Но т.к. иногда это невозможно, то она транспонируется по частям, blendf.
### формат пикселей
зачем использовать ещё ссе? Для перевода формата пикселей. Скажем, было rgba, а нужно argb. Если для этого использовать скалярный код, то всё упрётся не в память, а в процессор. 
Как для такого использовать ссе? Записать в регистр сколько-то пикселей и сделать blendf. 

в ссе есть команды, которые читают из одного массива и пишут в другой. И получается так, что появляются лишние чтения-записи в память. Так что есть флажок, который говорит, что нужно заигнорить кеш. А значит, и все протоколы когерентности. non-temporal записи. Всё пишется в такой буфер, который никто не видит. Это ускоряет работу алгоритмов, которые пишут в память, на 2/3.

### strlen
ещё один пример - нужно сделать ф-ю вроде strlen, т.е. нужно найти первый символ в массиве, который удовл. какому-то предикату. Это можно сделать при помощи ссе. Т.е. можно идти по массиву большими пачками, пока не попадётся пачка, в которой есть нулевой символ. А дальше перейти на скалярный код. Но проблема в том, что многие строчки не очень большие и получается так, что сразу переходим на скалярный код.

как узнать позицию первой единицы в числе? 

arr[((v&-v)*0x077cb531u) >> 27]
{0,1,3,8,2,29,14,24,3,30, 27,20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 14, 16, 7, 26, 12, 18, 6, 11, 3, 10, 9} //WTF

-это на теории кодирования. Там это не расскажут, но расскажут про циклические коды. Короче, при помощи этой штуки можно пробежать биты от 0 до 31.  На самом деле, это даже не в теории кодирования. Это из комбинаторики. Последовательности De Bruijn.